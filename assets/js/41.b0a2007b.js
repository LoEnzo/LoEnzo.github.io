(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{608:function(t,r,e){t.exports=e.p+"assets/img/docker-containerized-and-vm-transparent-bg.992e5cf0.png"},791:function(t,r,e){"use strict";e.r(r);var v=e(10),_=Object(v.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"})]),t._v(" "),v("h2",{attrs:{id:"docker容器相关"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker容器相关"}},[t._v("#")]),t._v(" Docker容器相关")]),t._v(" "),v("h3",{attrs:{id:"docker"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker"}},[t._v("#")]),t._v(" Docker")]),t._v(" "),v("p",[v("strong",[t._v("Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口")]),t._v("。它是目前最流行的 Linux 容器解决方案。Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情")]),t._v(" "),v("h3",{attrs:{id:"dockerfile"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile"}},[t._v("#")]),t._v(" Dockerfile")]),t._v(" "),v("p",[t._v("Dockerfile 是拿来构建自定义镜像的，并没有直接生成容器。只是可以在运行镜像时运行容器而已，若是想使用这个镜像的话还需要使用docker run命令来运行这个镜像，从而生成运行一个容器")]),t._v(" "),v("h3",{attrs:{id:"docker-compose"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose"}},[t._v("#")]),t._v(" Docker Compose")]),t._v(" "),v("p",[t._v("docker-compose.yml是用来编排项目的，里面包含使用各种镜像创建的容器服务，使用的镜像可以是网络上的，也可以是根据使用Dockerfile文件来build生成的镜像，相当于是把上一步的这个工作给做了")]),t._v(" "),v("p",[t._v("docker-compose可以在单个服务器上创建多个容器，多个副本")]),t._v(" "),v("h3",{attrs:{id:"docker-swarm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker-swarm"}},[t._v("#")]),t._v(" Docker Swarm")]),t._v(" "),v("p",[t._v("Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机")]),t._v(" "),v("p",[t._v("docker swarm可以在多个服务器创建多个容器，多个副本，实现集群，负载均衡， 不过现在主要被Kubernetes替代")]),t._v(" "),v("h3",{attrs:{id:"kubernetes"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes"}},[t._v("#")]),t._v(" Kubernetes")]),t._v(" "),v("p",[t._v("google基于自己的borg开发的容器编排工具，目前主流，能实现docker swarm能实现的功能，且其他功能更加强大")]),t._v(" "),v("h3",{attrs:{id:"docker容器和传统虚拟机的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker容器和传统虚拟机的区别"}},[t._v("#")]),t._v(" Docker容器和传统虚拟机的区别")]),t._v(" "),v("p",[t._v("容器是在"),v("strong",[t._v("操作系统层面")]),t._v("上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在"),v("strong",[t._v("硬件层面")]),t._v("实现")]),t._v(" "),v("p",[t._v("容器")]),t._v(" "),v("p",[v("img",{attrs:{src:e(608),alt:"docker-containerized-and-vm-transparent-bg"}})]),t._v(" "),v("h2",{attrs:{id:"containerd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#containerd"}},[t._v("#")]),t._v(" containerd")]),t._v(" "),v("h3",{attrs:{id:"docker-和-contraierd-简单说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker-和-contraierd-简单说明"}},[t._v("#")]),t._v(" docker 和 contraierd 简单说明")]),t._v(" "),v("p",[t._v("docker 由 docker-client, dockerd, containerd, docker-shim, runc组成，所以containerd是docker的基础组件之一")]),t._v(" "),v("p",[t._v("从k8s的角度看，可以选择 containerd 或 docker 作为运行时组件：其中 containerd 调用链更短，组件更少，更稳定，占用节点资源更少。所以k8s后来的版本开始默认使用 containerd")]),t._v(" "),v("p",[t._v("containerd 相比于docker , 多了 namespace 概念，每个 image 和 container 都会在各自的namespace下可见。")]),t._v(" "),v("p",[t._v("docker 作为 k8s 容器运行时，调用关系为："),v("code",[t._v("kubelet --\x3e dockershim （在 kubelet 进程中） --\x3e dockerd --\x3e containerd")])]),t._v(" "),v("p",[t._v("containerd 作为 k8s 容器运行时，调用关系为："),v("code",[t._v("kubelet --\x3e cri plugin（在 containerd 进程中） --\x3e containerd")])]),t._v(" "),v("p",[t._v("containerd 相比 docker, 多了 namespace 概念，每个image 和 container 都会在对应的 namespace 下可见，k8s 会使用 k8a.io 作为命名空间，"),v("code",[t._v("crictl images list -n k8s.io")])]),t._v(" "),v("h3",{attrs:{id:"相关执行说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相关执行说明"}},[t._v("#")]),t._v(" 相关执行说明")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("ctr 是 containerd 的一个客户端工具。")])]),t._v(" "),v("li",[v("p",[t._v("crictl 是 CRI 兼容的容器运行时命令行接口，可以使用它来检查和调试 k8s 节点上的容器运行时和应用程序。")])]),t._v(" "),v("li",[v("p",[t._v("ctr -v 输出的是 containerd 的版本，crictl -v 输出的是当前 k8s 的版本")])])]),t._v(" "),v("h3",{attrs:{id:"常用命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("docker")]),t._v(" "),v("th",[t._v("ctr（containerd）")]),t._v(" "),v("th",[t._v("crictl（kubernetes）")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("命令")]),t._v(" "),v("td",[t._v("docker")]),t._v(" "),v("td",[t._v("ctr（containerd）")]),t._v(" "),v("td",[t._v("crictl（kubernetes）")])]),t._v(" "),v("tr",[v("td",[t._v("查看运行的容器")]),t._v(" "),v("td",[t._v("docker ps")]),t._v(" "),v("td",[t._v("ctr task ls/ctr container ls")]),t._v(" "),v("td",[t._v("crictl ps")])]),t._v(" "),v("tr",[v("td",[t._v("查看镜像")]),t._v(" "),v("td",[t._v("docker images")]),t._v(" "),v("td",[t._v("ctr image ls")]),t._v(" "),v("td",[t._v("crictl images")])]),t._v(" "),v("tr",[v("td",[t._v("查看容器日志")]),t._v(" "),v("td",[t._v("docker logs")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("crictl logs")])]),t._v(" "),v("tr",[v("td",[t._v("查看容器数据信息")]),t._v(" "),v("td",[t._v("docker inspect")]),t._v(" "),v("td",[t._v("ctr container info")]),t._v(" "),v("td",[t._v("crictl inspect")])]),t._v(" "),v("tr",[v("td",[t._v("查看容器资源")]),t._v(" "),v("td",[t._v("docker stats")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("crictl stats")])]),t._v(" "),v("tr",[v("td",[t._v("启动/关闭已有的容器")]),t._v(" "),v("td",[t._v("docker start/stop")]),t._v(" "),v("td",[t._v("ctr task start/kill")]),t._v(" "),v("td",[t._v("crictl start/stop")])]),t._v(" "),v("tr",[v("td",[t._v("运行一个新的容器")]),t._v(" "),v("td",[t._v("docker run")]),t._v(" "),v("td",[t._v("ctr run")]),t._v(" "),v("td",[t._v("无（最小单元为pod）")])]),t._v(" "),v("tr",[v("td",[t._v("修改镜像标签")]),t._v(" "),v("td",[t._v("docker tag")]),t._v(" "),v("td",[t._v("ctr image tag")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("创建一个新的容器")]),t._v(" "),v("td",[t._v("docker create")]),t._v(" "),v("td",[t._v("ctr container create")]),t._v(" "),v("td",[t._v("crictl create")])]),t._v(" "),v("tr",[v("td",[t._v("导入镜像")]),t._v(" "),v("td",[t._v("docker load")]),t._v(" "),v("td",[t._v("ctr image import")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("导出镜像")]),t._v(" "),v("td",[t._v("docker save")]),t._v(" "),v("td",[t._v("ctr image export")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("删除容器")]),t._v(" "),v("td",[t._v("docker rm")]),t._v(" "),v("td",[t._v("ctr container rm")]),t._v(" "),v("td",[t._v("crictl rm")])]),t._v(" "),v("tr",[v("td",[t._v("删除镜像")]),t._v(" "),v("td",[t._v("docker rmi")]),t._v(" "),v("td",[t._v("ctr image rm")]),t._v(" "),v("td",[t._v("crictl rmi")])]),t._v(" "),v("tr",[v("td",[t._v("拉取镜像")]),t._v(" "),v("td",[t._v("docker pull")]),t._v(" "),v("td",[t._v("ctr image pull")]),t._v(" "),v("td",[t._v("ctictl pull")])]),t._v(" "),v("tr",[v("td",[t._v("推送镜像")]),t._v(" "),v("td",[t._v("docker push")]),t._v(" "),v("td",[t._v("ctr image push")]),t._v(" "),v("td",[t._v("无")])]),t._v(" "),v("tr",[v("td",[t._v("在容器内部执行命令")]),t._v(" "),v("td",[t._v("docker exec")]),t._v(" "),v("td",[t._v("无")]),t._v(" "),v("td",[t._v("crictl exec")])])])]),t._v(" "),v("h2",{attrs:{id:"工具推荐"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工具推荐"}},[t._v("#")]),t._v(" 工具推荐：")]),t._v(" "),v("p",[v("strong",[t._v("dive")])]),t._v(" "),v("p",[t._v("A tool for exploring a docker image, layer contents, and discovering ways to shrink the size of your Docker/OCI image.\nhttps://github.com/wagoodman/dive")]),t._v(" "),v("p",[v("strong",[t._v("ctop")])]),t._v(" "),v("p",[t._v("容器监控工具\nhttps://github.com/bcicen/ctop")]),t._v(" "),v("p",[v("strong",[t._v("lazydocker")])]),t._v(" "),v("p",[t._v("A simple terminal UI for both docker and docker-compose, written in Go with the gocui library.\nhttps://github.com/jesseduffield/lazydocker")])])}),[],!1,null,null,null);r.default=_.exports}}]);